{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\ud83e\udd16\u26d3\ufe0f ergo-agent SDK","text":"<p>Give any LLM agent the power to interact with the Ergo blockchain.</p>"},{"location":"#what-is-ergo-agent","title":"What is ergo-agent?","text":"<p>ergo-agent-sdk is an open-source Python SDK that gives AI agents (Claude, GPT-4, LangChain, CrewAI) secure, autonomous access to the Ergo blockchain. Agents can read balances, fetch prices, execute DEX swaps, mint stablecoins via SigmaUSD, and bridge assets cross-chain via the Rosen Bridge. </p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install ergo-agent-sdk\n</code></pre>"},{"location":"#5-line-quickstart","title":"5-Line Quickstart","text":"<pre><code>from ergo_agent import ErgoNode, Wallet\nfrom ergo_agent.tools import ErgoToolkit\n\nnode = ErgoNode()\nwallet = Wallet.read_only(\"9f4QF8jQSBiHrgqrCDuS3L62MY6MaBFW5UeqNqfEi1mCfmPFxVo\")\ntoolkit = ErgoToolkit(node=node, wallet=wallet)\n\nprint(toolkit.get_erg_price())    # \u2192 {\"erg_usd\": 0.31, \"source\": \"oracle_pool_v2\"}\nprint(toolkit.get_wallet_balance())  # \u2192 {\"erg\": \"1.2345\", \"tokens\": [...]}\n</code></pre> <p>That's it. No node required, no wallet keys, no setup. The public Explorer API is used by default.</p>"},{"location":"#key-features","title":"Key Features","text":"Feature Description \ud83d\udd0d Read-only queries Balance, price, mempool \u2014 no keys needed \ud83d\udcb1 Spectrum DEX Swap quotes and orders on Spectrum Finance \ud83c\udfe6 SigmaUSD Stablecoins Mint and redeem SigUSD and SigRSV reserves \ud83c\udf09 Rosen Bridge Cross-chain asset bridging out of Ergo \ud83c\udfdb\ufe0f DAO Treasuries Draft proposals and execute multi-sig actions \ud83d\udcca Oracle prices Live ERG/USD from Oracle Pool v2 \ud83d\udd12 Privacy Pools Deposit, withdraw, and monitor ring-signature privacy pools \ud83d\udd27 LLM-ready OpenAI, Anthropic, and LangChain schemas \ud83d\udee1\ufe0f Safety layer Per-tx limits, daily caps, contract whitelists \ud83d\udd11 Wallet signing Sign transactions via Ergo node wallet API"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started \u2014 detailed setup for all three modes (read-only, node wallet, LLM agent)</li> <li>Tutorial: Hello, Ergo! \u2014 step-by-step walkthrough from zero to a working agent</li> <li>Architecture \u2014 how the SDK is structured and how Ergo's eUTXO model works</li> <li>API Reference \u2014 complete reference for all classes and methods</li> <li>Privacy Pools \u2014 deposit, withdraw, and monitor ring-signature privacy pools</li> </ul>"},{"location":"api-reference/","title":"API Reference","text":"<p>Complete reference for all public classes and methods.</p>"},{"location":"api-reference/#core","title":"Core","text":""},{"location":"api-reference/#ergonode","title":"ErgoNode","text":""},{"location":"api-reference/#ergo_agent.core.node.ErgoNode","title":"<code>ergo_agent.core.node.ErgoNode(node_url=PUBLIC_NODE_URL, explorer_url=PUBLIC_EXPLORER_URL, api_key=None, timeout=15.0)</code>","text":"<p>Synchronous client for the Ergo blockchain. Uses the public Explorer API by default \u2014 no node required.</p> Usage <p>node = ErgoNode()  # uses public API node = ErgoNode(node_url=\"http://localhost:9053\", api_key=\"secret\")</p>"},{"location":"api-reference/#ergo_agent.core.node.ErgoNode-functions","title":"Functions","text":""},{"location":"api-reference/#ergo_agent.core.node.ErgoNode.get_height","title":"<code>get_height()</code>","text":"<p>Return current blockchain height.</p>"},{"location":"api-reference/#ergo_agent.core.node.ErgoNode.get_network_info","title":"<code>get_network_info()</code>","text":"<p>Return full network state info.</p>"},{"location":"api-reference/#ergo_agent.core.node.ErgoNode.get_balance","title":"<code>get_balance(address)</code>","text":"<p>Return the ERG and token balance for an address.</p> <p>Returns:</p> Name Type Description <code>Balance</code> <code>Balance</code> <p>structured balance with ERG float and token list.</p>"},{"location":"api-reference/#ergo_agent.core.node.ErgoNode.get_unspent_boxes","title":"<code>get_unspent_boxes(address, limit=50)</code>","text":"<p>Return unspent boxes (UTXOs) for an address.</p> <p>Tries the local node's blockchain UTXO endpoint first (fastest, uses validated state), then falls back to the explorer API.</p>"},{"location":"api-reference/#ergo_agent.core.node.ErgoNode.get_transaction_history","title":"<code>get_transaction_history(address, offset=0, limit=20)</code>","text":"<p>Get recent transaction history for an address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>Ergo address</p> required <code>offset</code> <code>int</code> <p>pagination offset</p> <code>0</code> <code>limit</code> <code>int</code> <p>max transactions to return (default 20)</p> <code>20</code> <p>Returns:</p> Type Description <code>list[Transaction]</code> <p>list[Transaction]: recent transactions, newest first</p>"},{"location":"api-reference/#ergo_agent.core.node.ErgoNode.get_mempool_transactions","title":"<code>get_mempool_transactions(address)</code>","text":"<p>Return pending (unconfirmed) transactions for an address.</p>"},{"location":"api-reference/#ergo_agent.core.node.ErgoNode.get_oracle_pool_box","title":"<code>get_oracle_pool_box(oracle_pool_nft_id)</code>","text":"<p>Fetch the live oracle pool box by its NFT ID. Used to read ERG/USD price and other data feeds.</p> <p>The price is stored in register R4 as nanoERG per 1 USD cent.</p>"},{"location":"api-reference/#ergo_agent.core.node.ErgoNode.submit_transaction","title":"<code>submit_transaction(signed_tx)</code>","text":"<p>Submit a signed transaction to the network. If the local node rejects it due to an unsynchronized UTXO set, it automatically falls back to broadcasting via the Explorer API.</p> <p>Parameters:</p> Name Type Description Default <code>signed_tx</code> <code>dict[str, Any]</code> <p>signed transaction as a dict (ErgoTransaction format)</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>transaction ID</p>"},{"location":"api-reference/#ergo_agent.core.node.ErgoNode.close","title":"<code>close()</code>","text":"<p>Close the underlying HTTP client.</p>"},{"location":"api-reference/#wallet","title":"Wallet","text":""},{"location":"api-reference/#ergo_agent.core.wallet.Wallet","title":"<code>ergo_agent.core.wallet.Wallet(address, _private_key_hex=None, _node_wallet=False, read_only=False)</code>","text":"<p>Ergo wallet \u2014 holds the private key material and signs transactions.</p> Usage <p>wallet = Wallet.from_mnemonic(\"word1 word2 ...\") wallet = Wallet.from_node(node, wallet_password=\"secret\")  # uses node's built-in wallet wallet = Wallet.read_only(address=\"9f...\")  # no signing, query only</p>"},{"location":"api-reference/#ergo_agent.core.wallet.Wallet-attributes","title":"Attributes","text":""},{"location":"api-reference/#ergo_agent.core.wallet.Wallet.address","title":"<code>address = address</code>  <code>instance-attribute</code>","text":""},{"location":"api-reference/#ergo_agent.core.wallet.Wallet-functions","title":"Functions","text":""},{"location":"api-reference/#ergo_agent.core.wallet.Wallet.read_only","title":"<code>read_only(address)</code>  <code>classmethod</code>","text":"<p>Read-only wallet -- can query balances and build transactions, but cannot sign. Useful for monitoring agents.</p>"},{"location":"api-reference/#ergo_agent.core.wallet.Wallet.from_node_wallet","title":"<code>from_node_wallet(node_address)</code>  <code>classmethod</code>","text":"<p>Use the Ergo node's built-in wallet for signing. The node handles key storage and signing -- this SDK just triggers it.</p> <p>Parameters:</p> Name Type Description Default <code>node_address</code> <code>str</code> <p>the address from the node's loaded wallet</p> required"},{"location":"api-reference/#ergo_agent.core.wallet.Wallet.from_mnemonic","title":"<code>from_mnemonic(mnemonic, passphrase='')</code>  <code>classmethod</code>","text":"<p>Create a wallet from a BIP39 mnemonic phrase.</p> <p>Not yet implemented. Requires ergo-lib (sigma-rust) Python bindings for proper BIP32/44 key derivation (path m/44'/429'/0'/0/0).</p> <p>For now, use Wallet.from_node_wallet() or Wallet.read_only() instead.</p>"},{"location":"api-reference/#ergo_agent.core.wallet.Wallet.sign_transaction","title":"<code>sign_transaction(unsigned_tx, node=None, secrets=None)</code>","text":"<p>Sign an unsigned transaction.</p> <p>If using a node wallet, the node signs it. If using local keys, signs with the private key.</p> <p>Parameters:</p> Name Type Description Default <code>unsigned_tx</code> <code>dict[str, Any]</code> <p>the unsigned transaction dict</p> required <code>node</code> <code>Any | None</code> <p>ErgoNode instance (required for node_wallet mode)</p> <code>None</code> <code>secrets</code> <code>dict[str, Any] | None</code> <p>Optional signing secrets for protocols requiring extra proofs (e.g., ring signatures). Dict with: - 'dlog': list of secret hex strings for proveDlog - 'dht': list of DH tuple dicts with keys:     'secret', 'g', 'h', 'u', 'v' (all compressed hex)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Any]</code> <p>signed transaction ready for submission</p>"},{"location":"api-reference/#transactionbuilder","title":"TransactionBuilder","text":""},{"location":"api-reference/#ergo_agent.core.builder.TransactionBuilder","title":"<code>ergo_agent.core.builder.TransactionBuilder(node, wallet)</code>","text":"<p>Fluent builder for Ergo unsigned transactions.</p> <p>Usage (simple transfer):     tx = (         TransactionBuilder(node, wallet)         .send(to=\"9f...\", amount_erg=1.5)         .with_fee(0.001)         .build()     )</p> <p>Usage (contract interaction with context extensions):     tx = (         TransactionBuilder(node, wallet)         .with_input(pool_box, extension={\"0\": key_image_hex, \"1\": proof_hex})         .add_output_raw(ergo_tree=..., value_nanoerg=..., tokens=[...], registers={...})         .build()     )</p> <p>The builder: - Validates all destination addresses (checksum + network byte) - Supports explicit input boxes (for spending contract UTXOs) - Supports context extensions on inputs (for getVar() in ErgoScript) - Automatically selects additional wallet UTXOs if explicit inputs aren't enough - Converts addresses to ErgoTree hex (P2PK direct, P2S/P2SH via API) - Calculates change output - Returns an unsigned tx dict ready for signing</p>"},{"location":"api-reference/#ergo_agent.core.builder.TransactionBuilder-functions","title":"Functions","text":""},{"location":"api-reference/#ergo_agent.core.builder.TransactionBuilder.send","title":"<code>send(to, amount_erg)</code>","text":"<p>Add a simple ERG transfer output. (Deprecated: use send_funds)</p>"},{"location":"api-reference/#ergo_agent.core.builder.TransactionBuilder.send_token","title":"<code>send_token(to, token_id, amount)</code>","text":"<p>Add a token transfer output (also sends minimum ERG dust to the box).</p>"},{"location":"api-reference/#ergo_agent.core.builder.TransactionBuilder.send_funds","title":"<code>send_funds(to, amount_erg, tokens=None)</code>","text":"<p>Add a transfer output sending ERG and optionally multiple tokens.</p>"},{"location":"api-reference/#ergo_agent.core.builder.TransactionBuilder.mint_token","title":"<code>mint_token(name, description, amount, decimals)</code>","text":"<p>Mint a new native token (EIP-004 compliant).</p> <p>The token ID will be the ID of the first input box in the built transaction. The caller's wallet receives the minted tokens.</p>"},{"location":"api-reference/#ergo_agent.core.builder.TransactionBuilder.add_output_raw","title":"<code>add_output_raw(ergo_tree, value_nanoerg, tokens=None, registers=None)</code>","text":"<p>Add a raw output box (for custom contract interactions like DEX swaps).</p>"},{"location":"api-reference/#ergo_agent.core.builder.TransactionBuilder.with_input","title":"<code>with_input(box, extension=None)</code>","text":"<p>Add an explicit input box (for spending contract boxes like PoolBoxes).</p> <p>Parameters:</p> Name Type Description Default <code>box</code> <code>Box | str</code> <p>a Box object or a box ID string. If a string, the box will  be fetched from the node when build() is called.</p> required <code>extension</code> <code>dict[str, str | Constant] | None</code> <p>context extension variables for this input.        Keys are variable IDs (as strings, e.g. \"0\", \"1\"),        values are either serialized hex strings or native        <code>ergo_lib_python.chain.Constant</code> objects.        These correspond to getVarT calls in ErgoScript.</p> <code>None</code> Example <p>from ergo_lib_python.chain import Constant builder.with_input(pool_box, extension={     \"0\": Constant.from_i64(100),     \"1\": bytes(Constant(b\"metadata\")).hex(),  # manual hex works too })</p>"},{"location":"api-reference/#ergo_agent.core.builder.TransactionBuilder.build","title":"<code>build()</code>","text":"<p>Build the unsigned transaction dict.</p> <p>Supports three input modes: 1. Auto-selection only (default): selects wallet UTXOs to cover outputs + fee 2. Explicit only: uses only with_input() boxes 3. Mixed: explicit inputs first, then auto-selects wallet UTXOs for the remainder</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Any]</code> <p>unsigned transaction in Ergo API format</p>"},{"location":"api-reference/#address-utilities","title":"Address Utilities","text":""},{"location":"api-reference/#ergo_agent.core.address","title":"<code>ergo_agent.core.address</code>","text":"<p>Ergo address utilities: validation, encoding, ErgoTree resolution.</p> <p>Ergo uses a custom Base58 encoding with Blake2b-256 checksums. Address format: network_byte + content_bytes + checksum (4 bytes)</p> Network types <ul> <li>0x01 = mainnet P2PK</li> <li>0x02 = mainnet P2SH</li> <li>0x03 = mainnet P2S</li> <li>0x10 = testnet P2PK etc.</li> </ul> <p>Reference: https://docs.ergoplatform.com/dev/wallet/address/</p>"},{"location":"api-reference/#ergo_agent.core.address-classes","title":"Classes","text":""},{"location":"api-reference/#ergo_agent.core.address.AddressError","title":"<code>AddressError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised for invalid Ergo addresses.</p>"},{"location":"api-reference/#ergo_agent.core.address-functions","title":"Functions","text":""},{"location":"api-reference/#ergo_agent.core.address.is_valid_address","title":"<code>is_valid_address(address)</code>","text":"<p>Check if an Ergo address is valid without raising exceptions.</p>"},{"location":"api-reference/#ergo_agent.core.address.validate_address","title":"<code>validate_address(address)</code>","text":"<p>Validate an Ergo address using the native Sigma-Rust bindings.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>Ergo address string (Base58 encoded)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if valid</p> <p>Raises:</p> Type Description <code>AddressError</code> <p>if the address is malformed or has a bad checksum</p>"},{"location":"api-reference/#ergo_agent.core.address.is_mainnet_address","title":"<code>is_mainnet_address(address)</code>","text":"<p>Check if address is a mainnet address.</p>"},{"location":"api-reference/#ergo_agent.core.address.is_p2pk_address","title":"<code>is_p2pk_address(address)</code>","text":"<p>Check if address is a P2PK (pay-to-public-key) address.</p>"},{"location":"api-reference/#ergo_agent.core.address.get_address_type","title":"<code>get_address_type(address)</code>","text":"<p>Return a human-readable address type.</p>"},{"location":"api-reference/#ergo_agent.core.address.address_to_ergo_tree","title":"<code>address_to_ergo_tree(address, node_url='ignored')</code>","text":"<p>Convert an Ergo address to its ErgoTree hex representation.</p> <p>Uses natively compiled <code>ergo_lib</code> rust bindings to generate the exact ErgoTree offline, eliminating the need to query the node API.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>valid Ergo address</p> required <code>node_url</code> <code>str</code> <p>Kept for backwards compatibility but ignored.</p> <code>'ignored'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>ErgoTree hex string</p>"},{"location":"api-reference/#privacy-protocols","title":"Privacy Protocols","text":""},{"location":"api-reference/#ergo_agent.core.privacy","title":"<code>ergo_agent.core.privacy</code>","text":"<p>Privacy module for privacy pool \u2014 application-level ring-signature privacy pools.</p> <p>This module provides: - The NUMS second generator H (for key images / nullifiers) - The ErgoScript source for the PoolContract (deposit + withdrawal paths) - High-level helpers for constructing deposit and withdrawal transactions</p> Architecture <p>PoolBox {     tokens: [(poolTokenId, totalReserve)]     R4: Coll[GroupElement] \u2014 deposit keys     R5: AvlTree \u2014 nullifier set (used key images)     R6: Long \u2014 denomination     R7: Int \u2014 maxDeposits (8 or 16) }</p> <p>Deposit: add a key to R4, add tokens to the pool Withdrawal: ring-signature proves ownership of one key, key image as nullifier</p>"},{"location":"api-reference/#ergo_agent.core.privacy-attributes","title":"Attributes","text":""},{"location":"api-reference/#ergo_agent.core.privacy.POOL_CONTRACT_SCRIPT","title":"<code>POOL_CONTRACT_SCRIPT = '\\n{\\n    val poolKeys  = SELF.R4[Coll[GroupElement]].get\\n    val denom     = SELF.R6[Long].get\\n    val maxRing   = SELF.R7[Int].get\\n    val poolOut   = OUTPUTS(0)\\n    val H = decodePoint(fromBase16(\"' + NUMS_H_HEX + '\"))\\n    val tokenDiff = poolOut.tokens(0)._2 - SELF.tokens(0)._2\\n\\n    if (tokenDiff &gt; 0L) {\\n        val scriptOk = poolOut.propositionBytes == SELF.propositionBytes\\n        val denomOk  = poolOut.R6[Long].get == denom\\n        val maxOk    = poolOut.R7[Int].get == maxRing\\n        val treeOk   = poolOut.R5[AvlTree].get.digest == SELF.R5[AvlTree].get.digest\\n        val tokenIdOk = poolOut.tokens(0)._1 == SELF.tokens(0)._1\\n        val tokenOk = (tokenDiff % denom) == 0L\\n        val tickets: Int = (tokenDiff / denom).toInt\\n        val newKeys  = poolOut.R4[Coll[GroupElement]].get\\n        val sizeOk   = newKeys.size == poolKeys.size + tickets\\n        val spaceOk  = newKeys.size &lt;= maxRing\\n        val oldKeysOk = poolKeys.indices.forall { (i: Int) =&gt; newKeys(i) == poolKeys(i) }\\n        val newKey = newKeys(poolKeys.size)\\n        val newKeyValid = newKey != groupGenerator\\n        val uniqueKeyOk = poolKeys.forall { (pk: GroupElement) =&gt; pk != newKey }\\n        sigmaProp(scriptOk &amp;&amp; denomOk &amp;&amp; maxOk &amp;&amp; treeOk &amp;&amp; tokenIdOk &amp;&amp; tokenOk &amp;&amp;\\n                  sizeOk &amp;&amp; spaceOk &amp;&amp; oldKeysOk &amp;&amp; newKeyValid &amp;&amp; uniqueKeyOk)\\n    } else if (tokenDiff &lt; 0L) {\\n        val ringOk   = poolKeys.size &gt;= 2\\n        val scriptOk = poolOut.propositionBytes == SELF.propositionBytes\\n        val denomOk  = poolOut.R6[Long].get == denom\\n        val maxOk    = poolOut.R7[Int].get == maxRing\\n        val keysOk   = poolOut.R4[Coll[GroupElement]].get == poolKeys\\n        val tokenIdOk = poolOut.tokens(0)._1 == SELF.tokens(0)._1\\n        val tokenOk  = tokenDiff == -denom\\n        val keyImage    = getVar[GroupElement](0).get\\n        val insertProof = getVar[Coll[Byte]](1).get\\n        val keyImageSafe = keyImage != groupGenerator\\n        val keyImageNotH = keyImage != H\\n        val curTree  = SELF.R5[AvlTree].get\\n        val newTree  = curTree.insert(\\n            Coll((keyImage.getEncoded, Coll[Byte]())),\\n            insertProof\\n        ).get\\n        val treeOk   = poolOut.R5[AvlTree].get.digest == newTree.digest\\n        val noteOutOk = if (OUTPUTS.size &gt; 1 &amp;&amp; OUTPUTS(1).tokens.size &gt; 0) {\\n            OUTPUTS(1).tokens(0)._1 == SELF.tokens(0)._1 &amp;&amp; OUTPUTS(1).tokens(0)._2 == denom\\n        } else { false }\\n        val ringProof = atLeast(1, poolKeys.map { (pk: GroupElement) =&gt;\\n            proveDlog(pk) &amp;&amp; proveDHTuple(groupGenerator, H, pk, keyImage)\\n        })\\n        sigmaProp(ringOk &amp;&amp; scriptOk &amp;&amp; denomOk &amp;&amp; maxOk &amp;&amp; keysOk &amp;&amp;\\n                  tokenIdOk &amp;&amp; tokenOk &amp;&amp; noteOutOk &amp;&amp; treeOk &amp;&amp;\\n                  keyImageSafe &amp;&amp; keyImageNotH) &amp;&amp; ringProof\\n    } else {\\n        val hasTokens  = SELF.tokens(0)._2 &gt; 0L\\n        val ageOk      = HEIGHT - SELF.creationInfo._1 &gt;= 788400\\n        val scriptOk   = poolOut.propositionBytes == SELF.propositionBytes\\n        val keysOk     = poolOut.R4[Coll[GroupElement]].get == poolKeys\\n        val nullOk     = poolOut.R5[AvlTree].get.digest == SELF.R5[AvlTree].get.digest\\n        val denomOk    = poolOut.R6[Long].get == denom\\n        val maxOk      = poolOut.R7[Int].get == maxRing\\n        val tokenIdOk  = poolOut.tokens(0)._1 == SELF.tokens(0)._1\\n        val tokenAmtOk = tokenDiff == 0L\\n        sigmaProp(hasTokens &amp;&amp; ageOk &amp;&amp; scriptOk &amp;&amp; keysOk &amp;&amp; nullOk &amp;&amp;\\n                  denomOk &amp;&amp; maxOk &amp;&amp; tokenIdOk &amp;&amp; tokenAmtOk)\\n    }\\n}\\n'</code>  <code>module-attribute</code>","text":""},{"location":"api-reference/#ergo_agent.core.privacy.NUMS_H_HEX","title":"<code>NUMS_H_HEX = '022975f1d28b92b6e84499b83b0797ef5235553eeb7edaa0cea243c1128c2fe739'</code>  <code>module-attribute</code>","text":""},{"location":"api-reference/#ergo_agent.core.privacy-functions","title":"Functions","text":""},{"location":"api-reference/#ergo_agent.core.privacy.generate_fresh_secret","title":"<code>generate_fresh_secret()</code>","text":"<p>Securely generates a fresh mathematical secret (private key) and its corresponding public key (compressed secp256k1 point) for a pool deposit.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[str, str]</code> <p>(private_key_hex, public_key_compressed_hex)</p>"},{"location":"api-reference/#ergo_agent.core.privacy.compute_key_image","title":"<code>compute_key_image(secret_hex)</code>","text":"<p>Compute the key image (nullifier) M = secret * H for a withdrawal.</p> <p>The key image is used to prevent double-spending: once a key image is inserted into the AvlTree nullifier set, the same secret cannot be used again.</p> <p>Parameters:</p> Name Type Description Default <code>secret_hex</code> <code>str</code> <p>The 32-byte secret (private key) as hex string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Compressed GroupElement hex of the key image (33 bytes / 66 chars).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the secret is not a valid 32-byte hex string or is zero.</p>"},{"location":"api-reference/#ergo_agent.core.privacy.generate_avl_insert_proof","title":"<code>generate_avl_insert_proof(key_image_hex, current_r5_hex=None)</code>","text":"<p>Generate an AvlTree insert proof for the key image nullifier.</p> <p>Uses the <code>ergo_avltree</code> Python extension (PyO3 wrapper around <code>ergo_avltree_rust</code>) to create and insert into the authenticated AVL+ tree.</p> <p>Parameters:</p> Name Type Description Default <code>key_image_hex</code> <code>str</code> <p>Compressed GroupElement hex of the key image.</p> required <code>current_r5_hex</code> <code>str | None</code> <p>Current R5 register hex (AvlTree). If None, assumes an empty tree.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[bytes, str]</code> <p>(proof_bytes, new_r5_hex) where new_r5_hex is the full Sigma-serialized AvlTree constant for the output box R5.</p>"},{"location":"api-reference/#ergo_agent.core.privacy.serialize_context_extension","title":"<code>serialize_context_extension(key_image_hex, proof_bytes)</code>","text":"<p>Build the context extension dict for a withdrawal transaction input.</p> <p>Var 0: GroupElement (type 0x07 + 33 compressed bytes) Var 1: Coll[Byte] (type 0x0e + VLQ length + raw bytes)</p> <p>Parameters:</p> Name Type Description Default <code>key_image_hex</code> <code>str</code> <p>Compressed key image hex (66 chars).</p> required <code>proof_bytes</code> <code>bytes</code> <p>Raw AvlTree insert proof bytes.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict mapping string var indices to hex-encoded Sigma values.</p>"},{"location":"api-reference/#ergo_agent.core.privacy.find_optimal_pool","title":"<code>find_optimal_pool(node, pool_ergo_tree, pool_token_id, denomination)</code>","text":"<p>Finds an optimal, un-congested PoolBox for a deposit to mitigate UTXO contention.</p> <p>Queries the blockchain for all unspent PoolBoxes matching the ErgoTree contract, filters for those serving the requested denomination that have available capacity, and returns a randomly selected pool to spread out concurrent deposits.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>ErgoNode</code> <p>Connected ErgoNode client</p> required <code>pool_ergo_tree</code> <code>str</code> <p>ErgoTree hex of the pool contract</p> required <code>pool_token_id</code> <code>str</code> <p>The privacy pool token ID</p> required <code>denomination</code> <code>int</code> <p>The denomination amount requested</p> required <p>Returns:</p> Name Type Description <code>Box</code> <code>Box</code> <p>A matched, unsaturated PoolBox.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no valid pools with available capacity are found.</p>"},{"location":"api-reference/#ergo_agent.core.privacy.build_pool_deposit_tx","title":"<code>build_pool_deposit_tx(builder, pool_box, note_box, depositor_public_keys_hex, pool_ergo_tree, pool_token_id, denomination)</code>","text":"<p>Build a deposit transaction: send a NoteBox's tokens into a PoolBox.</p> <p>The depositor's public keys are appended to the pool's key list (R4). The pool's token reserve increases by (denomination * number of keys).</p> <p>Parameters:</p> Name Type Description Default <code>builder</code> <code>TransactionBuilder</code> <p>a TransactionBuilder instance</p> required <code>pool_box</code> <code>Box</code> <p>the PoolBox to deposit into</p> required <code>note_box</code> <code>Box</code> <p>the NoteBox being deposited (must contain enough tokens)</p> required <code>depositor_public_keys_hex</code> <code>list[str]</code> <p>list of the depositor's one-time public keys</p> required <code>pool_ergo_tree</code> <code>str</code> <p>the ErgoTree hex of the pool contract</p> required <code>pool_token_id</code> <code>str</code> <p>the privacy pool token ID</p> required <code>denomination</code> <code>int</code> <p>the denomination amount (must match pool's R6)</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>unsigned transaction dict</p>"},{"location":"api-reference/#ergo_agent.core.privacy.build_pool_withdraw_tx","title":"<code>build_pool_withdraw_tx(builder, pool_box, secret_hex, recipient_ergo_tree, pool_ergo_tree, pool_token_id, denomination)</code>","text":"<p>Build a withdrawal transaction: ring-signature proof to withdraw from a PoolBox.</p> <p>Computes the key image from the secret, generates the AvlTree insert proof, and serializes the context extension. The ring proof itself is generated by the node's prover at signing time.</p> <p>Parameters:</p> Name Type Description Default <code>builder</code> <code>TransactionBuilder</code> <p>a TransactionBuilder instance</p> required <code>pool_box</code> <code>Box</code> <p>the PoolBox to withdraw from</p> required <code>secret_hex</code> <code>str</code> <p>the depositor's 32-byte secret key (hex)</p> required <code>recipient_ergo_tree</code> <code>str</code> <p>ErgoTree of the withdrawal recipient</p> required <code>pool_ergo_tree</code> <code>str</code> <p>ErgoTree hex of the pool contract</p> required <code>pool_token_id</code> <code>str</code> <p>the privacy pool token ID</p> required <code>denomination</code> <code>int</code> <p>amount to withdraw (must match pool's R6)</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>unsigned transaction dict</p>"},{"location":"api-reference/#ergo_agent.core.privacy.decompose_into_tiers","title":"<code>decompose_into_tiers(amount)</code>","text":"<p>Greedy decomposition algorithm for privacy pool \"Auto-Route\" mechanism. Breaks any amount into the optimal number of deposits across the 4 pool tiers.</p> <p>Tiers (in tokens): 1,000,000 | 100,000 | 10,000 | 1,000</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>Total token amount to anonymize</p> required <p>Returns:</p> Type Description <code>dict[int, int]</code> <p>dict mapping denomination to number of required tickets (keys)</p> <code>dict[int, int]</code> <p>e.g., 15,300,000 -&gt; {1000000: 15, 100000: 3, 10000: 0, 1000: 0}</p> <p>Note: Any \"loose change\" remainder (&lt; 1,000) cannot be deposited and is ignored here.</p>"},{"location":"api-reference/#data-models","title":"Data Models","text":""},{"location":"api-reference/#ergo_agent.core.models.Box","title":"<code>ergo_agent.core.models.Box</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>An unspent Ergo UTXO box.</p>"},{"location":"api-reference/#ergo_agent.core.models.Box-attributes","title":"Attributes","text":""},{"location":"api-reference/#ergo_agent.core.models.Box.value_erg","title":"<code>value_erg</code>  <code>property</code>","text":"<p>ERG value (human-readable).</p>"},{"location":"api-reference/#ergo_agent.core.models.Box-functions","title":"Functions","text":""},{"location":"api-reference/#ergo_agent.core.models.Box.decode_register","title":"<code>decode_register(register_id)</code>","text":"<p>Dynamically decode a raw Box register hex string natively using ergo-lib-python's <code>Constant.from_bytes</code> schema back into its typed Python equivalent.</p> <p>Parameters:</p> Name Type Description Default <code>register_id</code> <code>str</code> <p>The register to fetch (e.g. 'R4', 'R5')</p> required <p>Returns:</p> Type Description <code>Any | None</code> <p>The parsed python value, or None if the register is missing or unparseable.</p>"},{"location":"api-reference/#ergo_agent.core.models.Balance","title":"<code>ergo_agent.core.models.Balance</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Wallet balance summary.</p>"},{"location":"api-reference/#ergo_agent.core.models.Balance-functions","title":"Functions","text":""},{"location":"api-reference/#ergo_agent.core.models.Balance.to_agent_summary","title":"<code>to_agent_summary()</code>","text":"<p>Human-readable summary for the LLM.</p>"},{"location":"api-reference/#ergo_agent.core.models.Token","title":"<code>ergo_agent.core.models.Token</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A token held in an Ergo box.</p>"},{"location":"api-reference/#ergo_agent.core.models.Token-attributes","title":"Attributes","text":""},{"location":"api-reference/#ergo_agent.core.models.Token.amount_display","title":"<code>amount_display</code>  <code>property</code>","text":"<p>Human-readable amount adjusted for decimals.</p>"},{"location":"api-reference/#ergo_agent.core.models.SwapQuote","title":"<code>ergo_agent.core.models.SwapQuote</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A DEX swap quote from Spectrum.</p>"},{"location":"api-reference/#ergo_agent.core.models.SwapQuote-attributes","title":"Attributes","text":""},{"location":"api-reference/#ergo_agent.core.models.SwapQuote.price","title":"<code>price</code>  <code>property</code>","text":"<p>Effective exchange rate.</p>"},{"location":"api-reference/#ergo_agent.core.models.Transaction","title":"<code>ergo_agent.core.models.Transaction</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A submitted or confirmed transaction.</p>"},{"location":"api-reference/#defi","title":"DeFi","text":""},{"location":"api-reference/#oraclereader","title":"OracleReader","text":""},{"location":"api-reference/#ergo_agent.defi.oracle.OracleReader","title":"<code>ergo_agent.defi.oracle.OracleReader(node)</code>","text":"<p>Read live prices from the Ergo Oracle Pool v2.</p> Usage <p>oracle = OracleReader(node) price = oracle.get_erg_usd_price()  # e.g. 0.87 print(f\"ERG/USD: ${price:.2f}\")</p>"},{"location":"api-reference/#ergo_agent.defi.oracle.OracleReader-functions","title":"Functions","text":""},{"location":"api-reference/#ergo_agent.defi.oracle.OracleReader.get_erg_usd_price","title":"<code>get_erg_usd_price()</code>","text":"<p>Return the current ERG/USD price from the oracle pool.</p> <p>The oracle R4 value is nanoERG per 1 USD. We convert: price_usd = NANOERG_PER_ERG / nanoERG_per_USD</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>ERG price in USD (e.g. 0.31 means 1 ERG = $0.31)</p>"},{"location":"api-reference/#ergo_agent.defi.oracle.OracleReader.get_erg_usd_nanoerg_per_usd","title":"<code>get_erg_usd_nanoerg_per_usd()</code>","text":"<p>Return the raw oracle value: nanoERG per 1 USD. This is the value used directly in ErgoScript contracts.</p>"},{"location":"api-reference/#ergo_agent.defi.oracle.OracleReader.get_oracle_box_id","title":"<code>get_oracle_box_id(pair='erg_usd')</code>","text":"<p>Return the current oracle pool box ID. Used when adding an oracle box as a data input to a transaction.</p>"},{"location":"api-reference/#spectrumdex","title":"SpectrumDEX","text":""},{"location":"api-reference/#ergo_agent.defi.spectrum.SpectrumDEX","title":"<code>ergo_agent.defi.spectrum.SpectrumDEX(node, api_url=SPECTRUM_API, timeout=15.0)</code>","text":"<p>Adapter for Spectrum Finance DEX on Ergo.</p> Usage <p>dex = SpectrumDEX(node) markets = dex.get_pools() quote = dex.get_quote(token_in=\"ERG\", token_out=\"SigUSD\", amount_erg=10.0) print(f\"You get: {quote.token_out_amount} SigUSD\")</p>"},{"location":"api-reference/#ergo_agent.defi.spectrum.SpectrumDEX-functions","title":"Functions","text":""},{"location":"api-reference/#ergo_agent.defi.spectrum.SpectrumDEX.get_pools","title":"<code>get_pools(offset=0, limit=100)</code>","text":"<p>Fetch active Spectrum markets (trading pairs).</p> <p>Returns:</p> Type Description <code>list[Market]</code> <p>list[Market]: sorted by volume descending</p>"},{"location":"api-reference/#ergo_agent.defi.spectrum.SpectrumDEX.get_erg_price_in_sigusd","title":"<code>get_erg_price_in_sigusd()</code>","text":"<p>Convenience: get ERG/USD price from DEX pool directly. Note: use OracleReader for the canonical on-chain oracle price.</p>"},{"location":"api-reference/#ergo_agent.defi.spectrum.SpectrumDEX.get_quote","title":"<code>get_quote(token_in, token_out, amount_erg=None, amount_token=None)</code>","text":"<p>Get a swap quote for a given input.</p> <p>This uses the Spectrum API's last price data to estimate the output. Note: for exact on-chain output, pool box reserves should be read directly. The API price gives a good approximation.</p> <p>Parameters:</p> Name Type Description Default <code>token_in</code> <code>str</code> <p>input token (name or ID, use \"ERG\" for native ERG)</p> required <code>token_out</code> <code>str</code> <p>output token (name or ID)</p> required <code>amount_erg</code> <code>float | None</code> <p>if token_in is ERG, specify amount in ERG</p> <code>None</code> <code>amount_token</code> <code>int | None</code> <p>if token_in is a token, specify raw amount</p> <code>None</code> <p>Returns:</p> Type Description <code>SwapQuote</code> <p>SwapQuote with expected output amount and price impact</p>"},{"location":"api-reference/#ergo_agent.defi.spectrum.SpectrumDEX.build_swap_order","title":"<code>build_swap_order(token_in, token_out, amount_erg, return_address, min_output=None, max_slippage_pct=1.0)</code>","text":"<p>Build a Spectrum DEX swap order dict for TransactionBuilder.add_output_raw().</p> <p>On Ergo's eUTXO model, DEX swaps work via order boxes: 1. User creates an order box containing ERG + order parameters 2. Spectrum off-chain bots detect this box and execute the swap 3. User receives output tokens in a new box at their address</p> <p>Parameters:</p> Name Type Description Default <code>token_in</code> <code>str</code> <p>input token name (e.g. \"ERG\")</p> required <code>token_out</code> <code>str</code> <p>output token name (e.g. \"SigUSD\")</p> required <code>amount_erg</code> <code>float</code> <p>amount of ERG to swap</p> required <code>return_address</code> <code>str</code> <p>address to receive output tokens</p> required <code>min_output</code> <code>int | None</code> <p>minimum acceptable output amount (auto-calculated if None)</p> <code>None</code> <code>max_slippage_pct</code> <code>float</code> <p>max slippage for auto min_output calculation</p> <code>1.0</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict with 'ergo_tree', 'value_nanoerg', 'tokens', 'registers'</p> <code>dict[str, Any]</code> <p>ready for TransactionBuilder.add_output_raw()</p>"},{"location":"api-reference/#ergo_agent.defi.spectrum.SpectrumDEX.close","title":"<code>close()</code>","text":""},{"location":"api-reference/#sigmausd","title":"SigmaUSD","text":""},{"location":"api-reference/#ergo_agent.defi.sigmausd.SigmaUSD","title":"<code>ergo_agent.defi.sigmausd.SigmaUSD(node=None)</code>","text":"<p>Client for interacting with the SigmaUSD / AgeUSD protocol on Ergo. Provides read-only access to bank state, reserve ratio, prices, and transaction builders for minting/redeeming stablecoins.</p> <p>Initialize the SigmaUSD client.</p>"},{"location":"api-reference/#ergo_agent.defi.sigmausd.SigmaUSD-functions","title":"Functions","text":""},{"location":"api-reference/#ergo_agent.defi.sigmausd.SigmaUSD.get_bank_state","title":"<code>get_bank_state()</code>","text":"<p>Fetch the current state of the SigmaUSD Bank. Returns the reserve ratio, SigUSD price, and SigRSV price in nanoERG.</p>"},{"location":"api-reference/#ergo_agent.defi.sigmausd.SigmaUSD.build_mint_sigusd_tx","title":"<code>build_mint_sigusd_tx(amount_sigusd, wallet)</code>","text":"<p>Build an unsigned transaction to mint SigUSD in exchange for ERG.</p> <p>Parameters:</p> Name Type Description Default <code>amount_sigusd</code> <code>int</code> <p>The integer amount of SigUSD cents to mint (e.g. 100 for 1.00 SigUSD).</p> required <code>wallet</code> <code>Any</code> <p>The Wallet instance of the user.</p> required <p>Returns:</p> Name Type Description <code>Dict</code> <code>dict[str, Any]</code> <p>Unsigned transaction dict ready for signing.</p>"},{"location":"api-reference/#ergo_agent.defi.sigmausd.SigmaUSD.build_redeem_sigusd_tx","title":"<code>build_redeem_sigusd_tx(amount_sigusd, wallet)</code>","text":"<p>Build an unsigned transaction to redeem SigUSD for ERG.</p>"},{"location":"api-reference/#rosenbridge","title":"RosenBridge","text":""},{"location":"api-reference/#ergo_agent.defi.rosen.RosenBridge","title":"<code>ergo_agent.defi.rosen.RosenBridge(node=None)</code>","text":"<p>Client for interacting with the Rosen Bridge. Provides read-only access to global TVL and transaction builders for sending assets cross-chain to Cardano, Bitcoin, etc.</p>"},{"location":"api-reference/#ergo_agent.defi.rosen.RosenBridge-functions","title":"Functions","text":""},{"location":"api-reference/#ergo_agent.defi.rosen.RosenBridge.get_bridge_status","title":"<code>get_bridge_status()</code>","text":"<p>Fetch the current status and TVL of the Rosen Bridge.</p>"},{"location":"api-reference/#ergo_agent.defi.rosen.RosenBridge.build_bridge_tx","title":"<code>build_bridge_tx(to_chain, to_address, amount_erg, tokens, wallet)</code>","text":"<p>Build an unsigned transaction to bridge assets via Rosen.</p> <p>Parameters:</p> Name Type Description Default <code>to_chain</code> <code>str</code> <p>Destination network (e.g. \"Cardano\", \"Bitcoin\")</p> required <code>to_address</code> <code>str</code> <p>Destination address on the target network</p> required <code>amount_erg</code> <code>float</code> <p>ERG amount to send</p> required <code>tokens</code> <code>dict[str, int]</code> <p>Dictionary of Ergo native tokens to send</p> required <code>wallet</code> <code>Any</code> <p>User's Wallet instance</p> required"},{"location":"api-reference/#ergotreasury","title":"ErgoTreasury","text":""},{"location":"api-reference/#ergo_agent.defi.treasury.ErgoTreasury","title":"<code>ergo_agent.defi.treasury.ErgoTreasury(node=None)</code>","text":"<p>Client for interacting with Ergo DAO Treasury or MultiSig wallets. Provides methods to build governance proposals, vote on proposals, and execute approved multi-sig transactions.</p>"},{"location":"api-reference/#ergo_agent.defi.treasury.ErgoTreasury-functions","title":"Functions","text":""},{"location":"api-reference/#ergo_agent.defi.treasury.ErgoTreasury.build_proposal_tx","title":"<code>build_proposal_tx(treasury_address, target_address, amount_erg, description, wallet)</code>","text":"<p>Build an unsigned transaction that submits a new funding proposal to the DAO.</p> <p>Parameters:</p> Name Type Description Default <code>treasury_address</code> <code>str</code> <p>The P2S address of the Treasury/MultiSig contract</p> required <code>target_address</code> <code>str</code> <p>The recipient address for the proposed funding</p> required <code>amount_erg</code> <code>float</code> <p>The amount of ERG requested in the proposal</p> required <code>description</code> <code>str</code> <p>A short string describing the proposal (stored in R4)</p> required <code>wallet</code> <code>Any</code> <p>The proposer's wallet instance</p> required"},{"location":"api-reference/#ergo_agent.defi.treasury.ErgoTreasury.build_vote_tx","title":"<code>build_vote_tx(proposal_box_id, vote, wallet)</code>","text":"<p>Build an unsigned transaction to cast a vote on an active proposal.</p>"},{"location":"api-reference/#ergo_agent.defi.treasury.ErgoTreasury.build_execute_tx","title":"<code>build_execute_tx(proposal_box_id, treasury_address, wallet)</code>","text":"<p>Build an unsigned transaction to execute a proposal that has reached consensus.</p>"},{"location":"api-reference/#tools","title":"Tools","text":""},{"location":"api-reference/#ergotoolkit","title":"ErgoToolkit","text":""},{"location":"api-reference/#ergo_agent.tools.toolkit.ErgoToolkit","title":"<code>ergo_agent.tools.toolkit.ErgoToolkit(node, wallet, safety=None)</code>","text":"<p>Unified AI agent toolkit for the Ergo blockchain.</p> <p>All methods are safe to call directly from an LLM's tool-calling loop. Every state-changing action is validated by the SafetyConfig before execution.</p>"},{"location":"api-reference/#ergo_agent.tools.toolkit.ErgoToolkit-functions","title":"Functions","text":""},{"location":"api-reference/#ergo_agent.tools.toolkit.ErgoToolkit.get_wallet_balance","title":"<code>get_wallet_balance()</code>","text":"<p>Get the current ERG and token balance of the agent's wallet.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict with 'erg' (float), 'tokens' (list), and 'summary' (str)</p>"},{"location":"api-reference/#ergo_agent.tools.toolkit.ErgoToolkit.get_erg_price","title":"<code>get_erg_price()</code>","text":"<p>Get the current ERG/USD price from the Ergo Oracle Pool.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict with 'erg_usd' (float) and 'source' (str)</p>"},{"location":"api-reference/#ergo_agent.tools.toolkit.ErgoToolkit.get_swap_quote","title":"<code>get_swap_quote(token_in, token_out, amount_erg=None, amount_token=None)</code>","text":"<p>Get a swap quote from Spectrum DEX without executing it.</p> <p>Parameters:</p> Name Type Description Default <code>token_in</code> <code>str</code> <p>Input token (e.g. \"ERG\", \"SigUSD\")</p> required <code>token_out</code> <code>str</code> <p>Output token (e.g. \"SigUSD\", \"ERG\")</p> required <code>amount_erg</code> <code>float | None</code> <p>Amount in ERG if token_in is ERG</p> <code>None</code> <code>amount_token</code> <code>int | None</code> <p>Raw token amount if token_in is a token</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict with expected output, price impact, and fee info</p>"},{"location":"api-reference/#ergo_agent.tools.toolkit.ErgoToolkit.get_mempool_status","title":"<code>get_mempool_status()</code>","text":"<p>Check for pending transactions from this wallet.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict with pending transaction count and tx IDs</p>"},{"location":"api-reference/#ergo_agent.tools.toolkit.ErgoToolkit.get_safety_status","title":"<code>get_safety_status()</code>","text":"<p>Get current safety limits and usage status.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict with remaining daily budget, rate limit status, etc.</p>"},{"location":"api-reference/#ergo_agent.tools.toolkit.ErgoToolkit.swap_erg_for_token","title":"<code>swap_erg_for_token(token_out, amount_erg, max_slippage_pct=1.0)</code>","text":"<p>Swap ERG for a token on Spectrum DEX.</p> <p>Parameters:</p> Name Type Description Default <code>token_out</code> <code>str</code> <p>Token to receive (e.g. \"SigUSD\")</p> required <code>amount_erg</code> <code>float</code> <p>Amount of ERG to spend</p> required <code>max_slippage_pct</code> <code>float</code> <p>Maximum acceptable price impact (default 1%)</p> <code>1.0</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict with quote info and tx_id (or dry_run confirmation)</p>"},{"location":"api-reference/#ergo_agent.tools.toolkit.ErgoToolkit.mint_sigusd","title":"<code>mint_sigusd(amount_sigusd)</code>","text":"<p>Mint SigUSD using ERG from the wallet.</p>"},{"location":"api-reference/#ergo_agent.tools.toolkit.ErgoToolkit.redeem_sigusd","title":"<code>redeem_sigusd(amount_sigusd)</code>","text":"<p>Redeem SigUSD for ERG.</p>"},{"location":"api-reference/#ergo_agent.tools.toolkit.ErgoToolkit.mint_sigmrsv","title":"<code>mint_sigmrsv(amount_sigrsv)</code>","text":"<p>Mint SigRSV (Reserve coin) using ERG from the wallet.</p>"},{"location":"api-reference/#ergo_agent.tools.toolkit.ErgoToolkit.redeem_sigmrsv","title":"<code>redeem_sigmrsv(amount_sigrsv)</code>","text":"<p>Redeem SigRSV (Reserve coin) for ERG.</p>"},{"location":"api-reference/#ergo_agent.tools.toolkit.ErgoToolkit.bridge_assets","title":"<code>bridge_assets(to_chain, to_address, amount_erg=0.0, tokens=None)</code>","text":"<p>Bridge ERG or tokens to another blockchain via Rosen Bridge.</p>"},{"location":"api-reference/#ergo_agent.tools.toolkit.ErgoToolkit.create_treasury_proposal","title":"<code>create_treasury_proposal(treasury_address, target_address, amount_erg, description)</code>","text":"<p>Create a new funding proposal for an Ergo Treasury or MultiSig wallet.</p>"},{"location":"api-reference/#ergo_agent.tools.toolkit.ErgoToolkit.execute_tool","title":"<code>execute_tool(tool_name, tool_input)</code>","text":"<p>Execute a tool by name with given inputs. Used by LLM frameworks to dispatch tool calls.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>JSON-encoded result</p>"},{"location":"api-reference/#ergo_agent.tools.toolkit.ErgoToolkit.to_openai_tools","title":"<code>to_openai_tools()</code>","text":"<p>Generate OpenAI function-calling tool definitions.</p>"},{"location":"api-reference/#ergo_agent.tools.toolkit.ErgoToolkit.to_anthropic_tools","title":"<code>to_anthropic_tools()</code>","text":"<p>Generate Anthropic tool-use definitions.</p>"},{"location":"api-reference/#ergo_agent.tools.toolkit.ErgoToolkit.to_langchain_tools","title":"<code>to_langchain_tools()</code>","text":"<p>Generate LangChain BaseTool instances.</p>"},{"location":"api-reference/#safetyconfig","title":"SafetyConfig","text":""},{"location":"api-reference/#ergo_agent.tools.safety.SafetyConfig","title":"<code>ergo_agent.tools.safety.SafetyConfig(max_erg_per_tx=10.0, max_erg_per_day=50.0, allowed_contracts=(lambda: ['spectrum', 'sigmausd', 'rosen', 'privacy_pool'])(), rate_limit_per_hour=20, dry_run=False, min_withdrawal_delay_blocks=100, min_pool_ring_size=4, _action_timestamps=deque(), _daily_spend_log=list(), _deposit_heights=dict())</code>  <code>dataclass</code>","text":"<p>Configuration for agent spending limits and operational boundaries.</p> <p>Parameters:</p> Name Type Description Default <code>max_erg_per_tx</code> <code>float</code> <p>Hard cap on ERG per single transaction</p> <code>10.0</code> <code>max_erg_per_day</code> <code>float</code> <p>Rolling 24h cap on total ERG spent</p> <code>50.0</code> <code>allowed_contracts</code> <code>list[str]</code> <p>Whitelist of allowed interaction targets.                   Use protocol names (\"spectrum\", \"sigmausd\", \"rosen\")                   or raw Ergo addresses.</p> <code>(lambda: ['spectrum', 'sigmausd', 'rosen', 'privacy_pool'])()</code> <code>rate_limit_per_hour</code> <code>int</code> <p>Max number of state-changing actions per hour</p> <code>20</code> <code>dry_run</code> <code>bool</code> <p>If True, build transactions but never submit them</p> <code>False</code>"},{"location":"api-reference/#ergo_agent.tools.safety.SafetyConfig-functions","title":"Functions","text":""},{"location":"api-reference/#ergo_agent.tools.safety.SafetyConfig.validate_send","title":"<code>validate_send(amount_erg, destination)</code>","text":"<p>Validate a send action. Raises SafetyViolation if any limit is exceeded.</p> <p>Parameters:</p> Name Type Description Default <code>amount_erg</code> <code>float</code> <p>amount to send in ERG</p> required <code>destination</code> <code>str</code> <p>target address or protocol name</p> required"},{"location":"api-reference/#ergo_agent.tools.safety.SafetyConfig.validate_rate_limit","title":"<code>validate_rate_limit()</code>","text":"<p>Check that the agent hasn't exceeded the hourly action rate.</p>"},{"location":"api-reference/#ergo_agent.tools.safety.SafetyConfig.record_action","title":"<code>record_action(erg_spent=0.0)</code>","text":"<p>Record a completed action for rate limiting and daily spend tracking.</p>"},{"location":"api-reference/#ergo_agent.tools.safety.SafetyConfig.get_status","title":"<code>get_status()</code>","text":"<p>Return current safety status for agent awareness.</p>"},{"location":"api-reference/#ergo_agent.tools.safety.SafetyViolation","title":"<code>ergo_agent.tools.safety.SafetyViolation</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when an agent action violates the configured safety rules.</p>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#sdk-layers","title":"SDK Layers","text":"<p>The SDK is organized into three layers. Each layer only depends on the one below it.</p> <pre><code>graph TB\n    A[\"\ud83e\udd16 tools/&lt;br/&gt;ErgoToolkit, SafetyConfig&lt;br/&gt;OpenAI / Anthropic / LangChain schemas\"] --&gt; B\n    B[\"\ud83d\udcb1 defi/&lt;br/&gt;OracleReader, SpectrumDEX, SigmaUSD&lt;br/&gt;RosenBridge, PrivacyPoolClient, Treasury\"] --&gt; C\n    C[\"\u26d3\ufe0f core/&lt;br/&gt;ErgoNode, Wallet, TransactionBuilder&lt;br/&gt;Address, Privacy, Models\"]\n\n    style A fill:#7c3aed,color:#fff\n    style B fill:#f59e0b,color:#000\n    style C fill:#10b981,color:#fff</code></pre>"},{"location":"architecture/#core-layer-ergo_agentcore","title":"Core Layer (<code>ergo_agent.core</code>)","text":"<p>The foundation. Handles all direct blockchain interaction.</p> Class Purpose <code>ErgoNode</code> REST client for the Explorer API and node API <code>Wallet</code> Address management and transaction signing <code>TransactionBuilder</code> UTXO selection, fee calculation, change handling, explicit inputs + context extensions <code>address</code> Base58 validation, ErgoTree derivation, checksum verification <code>privacy</code> Privacy pool protocol: PrivacyPoolV6 contract, key image computation, AvlTree proofs, ring signature support <code>models</code> Data classes: <code>Box</code>, <code>Balance</code>, <code>Token</code>, <code>Transaction</code>, <code>SwapQuote</code>"},{"location":"architecture/#defi-layer-ergo_agentdefi","title":"DeFi Layer (<code>ergo_agent.defi</code>)","text":"<p>Protocol-specific adapters built on top of core.</p> Class Purpose <code>OracleReader</code> Reads ERG/USD price from Oracle Pool v2 <code>SpectrumDEX</code> Markets, swap quotes, and order construction for Spectrum Finance <code>SigmaUSD</code> Mint and redeem SigUSD/SigRSV via the AgeUSD bank contract <code>RosenBridge</code> Cross-chain asset bridging out of Ergo <code>PrivacyPoolClient</code> Ring-signature privacy pools: deposit, withdraw, health monitoring <code>ErgoTreasury</code> DAO proposal creation, voting, and execution"},{"location":"architecture/#tools-layer-ergo_agenttools","title":"Tools Layer (<code>ergo_agent.tools</code>)","text":"<p>The AI-facing interface. Wraps everything into LLM-compatible tool calls.</p> Class Purpose <code>ErgoToolkit</code> Main entry point \u2014 15 tools, JSON output, <code>execute_tool()</code> dispatch <code>SafetyConfig</code> Per-tx limits, daily caps, rate limiting, contract whitelist, privacy timing guards <code>to_openai_tools()</code> OpenAI function-calling schema <code>to_anthropic_tools()</code> Anthropic tool use schema <code>to_langchain_tools()</code> LangChain <code>@tool</code> wrappers"},{"location":"architecture/#how-ergos-eutxo-model-works","title":"How Ergo's eUTXO Model Works","text":"<p>For developers coming from EVM</p> <p>If you're used to Ethereum, Ergo's model is fundamentally different. This section explains the key concepts.</p>"},{"location":"architecture/#boxes-not-accounts","title":"Boxes, Not Accounts","text":"<p>Ergo doesn't have accounts with balances. Instead, it uses boxes (enhanced UTXOs):</p> <pre><code>graph LR\n    subgraph \"Transaction\"\n        direction LR\n        I1[\"\ud83d\udce6 Input Box&lt;br/&gt;5 ERG\"] --&gt; TX[\"\ud83d\udd04 Tx\"]\n        TX --&gt; O1[\"\ud83d\udce6 Output Box 1&lt;br/&gt;3 ERG \u2192 recipient\"]\n        TX --&gt; O2[\"\ud83d\udce6 Output Box 2&lt;br/&gt;1.999 ERG \u2192 change\"]\n        TX --&gt; O3[\"\ud83d\udce6 Output Box 3&lt;br/&gt;0.001 ERG \u2192 fee\"]\n    end</code></pre> <ul> <li>Input boxes are consumed (destroyed) by the transaction</li> <li>Output boxes are created by the transaction</li> <li>The sum of inputs must equal the sum of outputs (conservation)</li> <li>Your \"balance\" is the sum of all unspent boxes at your address</li> </ul>"},{"location":"architecture/#what-makes-ergo-boxes-special","title":"What Makes Ergo Boxes Special","text":"<p>Unlike Bitcoin UTXOs, Ergo boxes have:</p> Feature Description ErgoTree A script (compiled ErgoScript) that defines spending conditions Registers R0\u2013R9 Typed data storage \u2014 R0 is value, R1 is script, R4\u2013R9 are custom Tokens Each box can hold multiple tokens alongside ERG Creation height Block height when the box was created <p>This is why the SDK has a <code>TransactionBuilder</code> \u2014 constructing a transaction means selecting input boxes, creating output boxes, and handling change.</p>"},{"location":"architecture/#advanced-cryptography-privacy-pool-ring-signatures","title":"Advanced Cryptography: Privacy Pool Ring Signatures","text":"<p>Because Ergo uses Sigma Protocols natively, the SDK's <code>TransactionBuilder</code> and <code>privacy</code> modules support advanced zero-knowledge proofs like Ring Signatures out of the box:</p> <ol> <li>Deposit: A user generates a fresh secret+public key pair, adds their public key to a <code>PoolBox</code> (in register <code>R4</code>) and deposits tokens.</li> <li>Withdrawal: The SDK computes the key image (nullifier) from the depositor's secret (<code>M = secret \u00d7 H</code>), generates an AvlTree insert proof for the nullifier set (<code>R5</code>), and constructs a ring signature (<code>proveDlog</code> + <code>proveDHTuple</code> + <code>atLeast</code>) proving membership without revealing identity.</li> <li>Double-spend prevention: The key image is inserted into an authenticated AVL+ tree (<code>R5</code>). The contract verifies the proof and rejects duplicate key images.</li> </ol> <p>The unified PrivacyPoolV6 contract handles deposits, withdrawals, and renewal paths via lazy <code>if/else</code> branching on the token differential. The SDK abstracts all cryptographic complexity via <code>compute_key_image()</code>, <code>generate_avl_insert_proof()</code>, and <code>serialize_context_extension()</code>.</p>"},{"location":"architecture/#how-the-sdk-handles-this","title":"How the SDK Handles This","text":"<pre><code>sequenceDiagram\n    participant Agent as LLM Agent\n    participant Toolkit as ErgoToolkit\n    participant Builder as TransactionBuilder\n    participant Node as ErgoNode\n\n    Agent-&gt;&gt;Toolkit: send_erg(to=\"9f...\", amount=1.5)\n    Toolkit-&gt;&gt;Toolkit: SafetyConfig.validate()\n    Toolkit-&gt;&gt;Node: get_unspent_boxes(address)\n    Node--&gt;&gt;Toolkit: [Box, Box, Box, ...]\n    Toolkit-&gt;&gt;Builder: send(to, amount_erg)\n    Builder-&gt;&gt;Builder: Select inputs (greedy)\n    Builder-&gt;&gt;Builder: Create output + change + fee\n    Builder--&gt;&gt;Toolkit: unsigned_tx dict\n    Toolkit-&gt;&gt;Node: submit_transaction(tx)\n    Node--&gt;&gt;Agent: tx_id</code></pre> <p>The agent never sees UTXOs, box IDs, or ErgoTrees. It just calls <code>send_erg()</code> and gets back a transaction ID.</p>"},{"location":"architecture/#safety-architecture","title":"Safety Architecture","text":"<pre><code>graph LR\n    A[\"Agent calls&lt;br/&gt;send_erg()\"] --&gt; B{\"SafetyConfig\"}\n    B --&gt;|\"\u2705 passes\"| C[\"Execute\"]\n    B --&gt;|\"\u274c per-tx limit\"| D[\"SafetyViolation\"]\n    B --&gt;|\"\u274c daily limit\"| D\n    B --&gt;|\"\u274c rate limit\"| D\n    B --&gt;|\"\u274c contract not whitelisted\"| D</code></pre> <p>Every state-changing action passes through <code>SafetyConfig</code> before execution. The safety layer is not optional \u2014 even if you don't configure it, sensible defaults apply.</p> Guard Default Purpose <code>max_erg_per_tx</code> 100 ERG Prevent single catastrophic transaction <code>max_erg_per_day</code> 1000 ERG Rolling 24h spending cap <code>rate_limit_per_hour</code> 60 Prevent runaway loops <code>allowed_contracts</code> <code>[]</code> (any) Whitelist protocols the agent can interact with <code>dry_run</code> <code>False</code> Log but don't execute (for testing) <code>min_withdrawal_delay_blocks</code> 100 Recommended blocks between deposit and withdrawal <code>min_pool_ring_size</code> 4 Minimum ring size for withdrawal safety"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide gets you from zero to your first Ergo query in under 2 minutes.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>pip install ergo-agent\n</code></pre> <p>For LLM framework integration, install the extras you need:</p> OpenAIAnthropicLangChainAll <pre><code>pip install ergo-agent[openai]\n</code></pre> <pre><code>pip install ergo-agent[anthropic]\n</code></pre> <pre><code>pip install ergo-agent[langchain]\n</code></pre> <pre><code>pip install ergo-agent[all]\n</code></pre>"},{"location":"getting-started/#mode-1-read-only-no-wallet","title":"Mode 1: Read-Only (no wallet)","text":"<p>Perfect for price bots, portfolio trackers, and exploration.</p> <pre><code>from ergo_agent import ErgoNode, Wallet\nfrom ergo_agent.tools import ErgoToolkit\n\nnode = ErgoNode()  # uses public API \u2014 no node required\nwallet = Wallet.read_only(\"9f4QF8jQSBiHrgqrCDuS3L62MY6MaBFW5UeqNqfEi1mCfmPFxVo\")\ntoolkit = ErgoToolkit(node=node, wallet=wallet)\n\n# Check balance\nbalance = toolkit.get_wallet_balance()\nprint(balance)\n\n# Get live ERG/USD price\nprice = toolkit.get_erg_price()\nprint(price)\n</code></pre> <p>No API key needed</p> <p>The SDK uses the public <code>api.ergoplatform.com</code> by default. Rate limits are generous for development use.</p>"},{"location":"getting-started/#mode-2-node-wallet-transactions-enabled","title":"Mode 2: Node Wallet (transactions enabled)","text":"<p>For sending ERG, swapping tokens, and signing transactions.</p> <pre><code>from ergo_agent import ErgoNode, Wallet\nfrom ergo_agent.tools import ErgoToolkit, SafetyConfig\n\n# Connect to your own Ergo node\nnode = ErgoNode(node_url=\"http://localhost:9053\", api_key=\"your-api-key\")\nwallet = Wallet.from_node_wallet(\"9f...\")\n\ntoolkit = ErgoToolkit(\n    node=node,\n    wallet=wallet,\n    safety=SafetyConfig(\n        max_erg_per_tx=5.0,       # hard cap per transaction\n        max_erg_per_day=50.0,     # rolling 24h limit\n        rate_limit_per_hour=20,   # max 20 actions/hour\n    ),\n)\n\n# Send ERG (passes through safety checks)\nresult = toolkit.send_erg(to=\"9f...\", amount_erg=1.5)\n</code></pre> <p>Node required</p> <p>Transaction signing requires connecting to an Ergo node with the wallet API unlocked. See the Ergo node setup guide for instructions.</p>"},{"location":"getting-started/#mode-3-llm-agent-integration","title":"Mode 3: LLM Agent Integration","text":"<p>Connect any LLM to the Ergo blockchain with tool/function calling.</p> OpenAIAnthropicLangChain <pre><code>from ergo_agent import ErgoNode, Wallet\nfrom ergo_agent.tools import ErgoToolkit\n\nnode = ErgoNode()\nwallet = Wallet.read_only(\"9f...\")\ntoolkit = ErgoToolkit(node=node, wallet=wallet)\n\n# Generate OpenAI function-calling tool definitions\ntools = toolkit.to_openai_tools()\n# Pass `tools` to your OpenAI chat completion call\n</code></pre> <pre><code>tools = toolkit.to_anthropic_tools()\n# Pass `tools` to your Anthropic messages call\n</code></pre> <pre><code>lc_tools = toolkit.to_langchain_tools()\n# Use with LangChain's AgentExecutor or create_tool_calling_agent\n</code></pre> <p>When the LLM calls a tool, execute it:</p> <pre><code>result = toolkit.execute_tool(\"get_erg_price\", {})\n# Returns JSON string: {\"erg_usd\": 0.31, \"source\": \"oracle_pool_v2\"}\n</code></pre>"},{"location":"getting-started/#whats-next","title":"What's Next?","text":"<ul> <li>Tutorial: Hello, Ergo! \u2014 build a complete price-checking agent step by step</li> <li>Architecture \u2014 understand the SDK layers and Ergo's eUTXO model</li> <li>API Reference \u2014 look up any class or method</li> </ul>"},{"location":"privacy-pool-guide/","title":"Privacy Pool Protocol \u2014 Usage Guide","text":"<p>This guide covers the complete privacy pool workflow: depositing tokens, withdrawing anonymously, and monitoring pool health.</p>"},{"location":"privacy-pool-guide/#prerequisites","title":"Prerequisites","text":"<pre><code>pip install ergo-agent-sdk httpx\n</code></pre> <pre><code>from ergo_agent.core.node import ErgoNode\nfrom ergo_agent.core.wallet import Wallet\nfrom ergo_agent.defi.privacy_pool import PrivacyPoolClient\n</code></pre>"},{"location":"privacy-pool-guide/#quick-start","title":"Quick Start","text":"<pre><code>node = ErgoNode(\n    node_url=\"http://127.0.0.1:9052\",\n    explorer_url=\"https://api-testnet.ergoplatform.com\",\n    api_key=\"your_api_key\",\n)\nwallet = Wallet.from_node_wallet(\"your_address\")\npool = PrivacyPoolClient(node=node, wallet=wallet)\n</code></pre>"},{"location":"privacy-pool-guide/#1-pool-discovery","title":"1. Pool Discovery","text":""},{"location":"privacy-pool-guide/#list-active-pools","title":"List Active Pools","text":"<pre><code>pools = pool.get_active_pools(denomination=100)\nfor p in pools:\n    print(f\"Pool: {p['pool_id'][:16]}...\")\n    print(f\"  Ring: {p['depositors']}/{p['max_depositors']}\")\n    print(f\"  Slots: {p['slots_remaining']}\")\n    print(f\"  Tokens: {p['token_balance']}\")\n</code></pre>"},{"location":"privacy-pool-guide/#auto-select-best-pool","title":"Auto-Select Best Pool","text":"<pre><code>best = pool.select_best_pool(denomination=100)\nif best:\n    print(f\"Best pool: {best['pool_id'][:16]}... (ring={best['depositors']})\")\n</code></pre>"},{"location":"privacy-pool-guide/#2-deposit","title":"2. Deposit","text":"<pre><code>from ergo_agent.core.privacy import generate_fresh_secret\n\n# Generate a one-time secret + public key pair\nsecret_hex, stealth_key = generate_fresh_secret()\n\npool_id = best[\"pool_id\"]\nbuilder = pool.build_deposit_tx(pool_id, stealth_key, denomination=100)\ntx = builder.build()\nsigned = wallet.sign_transaction(tx, node)\ntx_id = node.submit_transaction(signed)\nprint(f\"Deposit TX: {tx_id}\")\n</code></pre> <p>Save Your Secret Key</p> <p>You must save <code>secret_hex</code> securely \u2014 it is required for withdrawal. Losing it means losing access to your deposited tokens permanently.</p> <p>Security Validations</p> <p>The SDK automatically blocks:</p> <ul> <li>groupGenerator as stealth key (trivially provable slot)</li> <li>H constant as stealth key (compromises DH tuple proof)</li> <li>Duplicate keys already in the pool's ring</li> <li>Full pools (capacity pre-check)</li> </ul>"},{"location":"privacy-pool-guide/#3-withdrawal","title":"3. Withdrawal","text":"<pre><code># Use the secret_hex saved during deposit\nrecipient = \"9h...\"  # Fresh Ergo address (never used before)\n\nbuilder = pool.build_withdrawal_tx(pool_id, recipient, secret_hex)\ntx = builder.build()\nsigned = wallet.sign_transaction(tx, node)\ntx_id = node.submit_transaction(signed)\n</code></pre> <p>The SDK handles everything internally:</p> <ol> <li>Computes the key image (nullifier) from your secret: <code>M = secret \u00d7 H</code></li> <li>Generates the AvlTree insert proof via <code>ergo_avltree</code></li> <li>Serializes context extension variables with correct Sigma types</li> <li>Builds the ring signature proof (handled by the node's prover at signing time)</li> </ol> <p>Privacy Best Practices</p> <ul> <li>Never reuse the recipient withdrawal address</li> <li>Wait at least 2 blocks between deposit and withdrawal</li> <li>Use a fresh IP address or Tor when withdrawing</li> <li>Check pool health before withdrawing \u2014 low ring sizes reduce anonymity</li> </ul>"},{"location":"privacy-pool-guide/#4-pool-health-analytics","title":"4. Pool Health Analytics","text":"<pre><code>health = pool.evaluate_pool_health(pool_id)\nprint(f\"Privacy Score: {health['privacy_score']}\")\nprint(f\"Effective Anonymity: {health['effective_anonymity']}\")\nprint(f\"Risk Flags: {health['risk_flags']}\")\n</code></pre> <p>Privacy Score Levels:</p> Score Meaning EXCELLENT 8+ unique depositors, no risk flags GOOD 6-7 unique depositors FAIR 4-5 unique depositors POOR 2-3 unique depositors CRITICAL &lt;2 unique depositors or multiple risk flags"},{"location":"privacy-pool-guide/#5-toolkit-agent-facing-api","title":"5. Toolkit (Agent-Facing API)","text":"<p>If you're using the <code>ErgoToolkit</code> for AI agent integration:</p> <pre><code>from ergo_agent.tools.toolkit import ErgoToolkit\n\ntoolkit = ErgoToolkit(node=node, wallet=wallet)\n\n# Deposit \u2014 auto-generates and returns the secret key\nresult = toolkit.deposit_to_privacy_pool(pool_id=\"...\", denomination=100)\nsecret_key = result[\"secret_key\"]  # Save this!\n\n# Withdraw \u2014 pass the secret key, everything else is computed internally\nresult = toolkit.withdraw_from_privacy_pool(\n    pool_id=\"...\",\n    recipient_address=\"9h...\",\n    secret_key=secret_key,\n)\n</code></pre>"},{"location":"privacy-pool-guide/#6-api-bridge-relayer","title":"6. API Bridge (Relayer)","text":"<p>For frontend integration, use the FastAPI relayer:</p> <pre><code>cd ergo\nuvicorn api.server:app --port 8000\n</code></pre> <p>Endpoints:</p> Method Path Description <code>GET</code> <code>/api/pools</code> List active pools <code>GET</code> <code>/api/pools/{id}/health</code> Pool health report <code>POST</code> <code>/api/deposit</code> Submit deposit TX <code>POST</code> <code>/api/withdraw</code> Submit withdrawal TX <code>GET</code> <code>/api/health</code> API health check"},{"location":"privacy-security-guide/","title":"Privacy Pool Security Guide","text":"<p>This document summarizes the threat model, hardening measures, and best practices for the privacy pool protocol.</p>"},{"location":"privacy-security-guide/#threat-model-summary","title":"Threat Model Summary","text":"<p>The privacy pool protocol was subjected to a comprehensive security analysis covering 5 categories:</p> Category Findings Status Cryptographic Edge Cases 4 \u2705 Fixed in PrivacyPoolV6 Input Sanitization 3 \u2705 Fixed in SDK Anonymity Set Quality 3 \u2705 Mitigated Pool Economics 4 \u2705 Addressed Privacy Leakage 3 \u2705 Mitigated"},{"location":"privacy-security-guide/#contract-guards-privacypoolv6es","title":"Contract Guards (PrivacyPoolV6.es)","text":"<p>The PrivacyPoolV6 contract uses a unified lazy-evaluation architecture with three paths (deposit, withdrawal, renewal) determined by <code>tokenDiff</code>:</p>"},{"location":"privacy-security-guide/#withdrawal-path-guards","title":"Withdrawal Path Guards","text":"<ol> <li><code>keyImageSafe</code> \u2014 Blocks <code>groupGenerator</code> as a key image (prevents nullifier poisoning)</li> <li><code>keyImageNotH</code> \u2014 Blocks the <code>H</code> constant as a key image</li> <li><code>treeOk</code> \u2014 Verifies the AvlTree insert proof: the new nullifier tree digest in the output must match the result of inserting the key image</li> <li><code>withdrawOk</code> \u2014 Ensures the withdrawal note receives the exact denomination (no fee deduction)</li> <li>Ring Signature \u2014 <code>atLeast(1, poolKeys.map(...))</code> with <code>proveDlog</code> + <code>proveDHTuple</code> proves membership without revealing which key</li> </ol>"},{"location":"privacy-security-guide/#deposit-path-guards","title":"Deposit Path Guards","text":"<ol> <li><code>spaceOk</code> \u2014 New key count must not exceed <code>maxN</code> (register R7)</li> <li><code>oldKeysOk</code> \u2014 Existing keys in R4 must be preserved in order</li> <li><code>newKeyValid</code> \u2014 New key must not be <code>groupGenerator</code></li> <li><code>uniqueKeyOk</code> \u2014 New key must not duplicate any existing key</li> <li><code>treeOk</code> \u2014 AvlTree nullifier set (R5) must remain unchanged during deposits</li> </ol>"},{"location":"privacy-security-guide/#avltree-nullifier-set-r5","title":"AvlTree Nullifier Set (R5)","text":"<p>The v6 contract replaced the previous <code>Coll[GroupElement]</code> nullifier list with an authenticated AVL+ tree (AvlTree). Benefits:</p> <ul> <li>O(log n) insert proof \u2014 scales to thousands of withdrawals</li> <li>Tamper-proof \u2014 digest-based verification prevents nullifier manipulation</li> <li>Node-validated \u2014 the Ergo node validates the full tree proof during signing</li> </ul> <p>The SDK generates insert proofs via the <code>ergo_avltree</code> Python extension (PyO3 wrapper around Rust implementation).</p>"},{"location":"privacy-security-guide/#sdk-validations","title":"SDK Validations","text":"<p>The Python SDK (<code>PrivacyPoolClient</code>) performs pre-flight checks before building transactions:</p> <ul> <li>Point format validation \u2014 66-char hex, <code>02</code>/<code>03</code> prefix, valid hex</li> <li>Banned key detection \u2014 Rejects <code>groupGenerator</code> and <code>H_CONSTANT</code> for both deposits and withdrawals</li> <li>Duplicate key detection \u2014 Parses R4 to check for existing keys before deposit</li> <li>Double-spend prevention \u2014 Validates key image not already in R5 AvlTree (deferred to node validator for full tree verification)</li> <li>Pool capacity pre-check \u2014 Refuses deposits to full pools</li> <li>Key image computation \u2014 <code>compute_key_image(secret_hex)</code> derives <code>M = secret \u00d7 H</code> internally</li> <li>AvlTree proof generation \u2014 <code>generate_avl_insert_proof()</code> creates the insert proof and new digest</li> </ul>"},{"location":"privacy-security-guide/#privacy-best-practices","title":"Privacy Best Practices","text":"<p>For Depositors</p> <ul> <li>Generate fresh stealth keys for every deposit (<code>generate_fresh_secret()</code>)</li> <li>Save your secret key \u2014 it is required for withdrawal and cannot be recovered</li> <li>Never reuse a stealth key across pools</li> <li>Wait for the pool to grow before withdrawing</li> </ul> <p>For Withdrawers</p> <ul> <li>Use a virgin address (never used before) as the recipient</li> <li>Wait at least 100 blocks after your deposit before withdrawing</li> <li>Use Tor or a VPN when communicating with the relayer</li> <li>Check <code>evaluate_pool_health()</code> \u2014 avoid pools with <code>CRITICAL</code> privacy score</li> </ul> <p>Known Limitations</p> <ul> <li>Ring size is capped at 16 \u2014 anonymity is bounded</li> <li>Timing analysis can correlate deposits/withdrawals if done immediately</li> <li>The relayer can see the withdrawal request (use Tor for max privacy)</li> <li>On-chain metadata leakage through ERG change amounts</li> <li>The v6 contract withdraws the exact denomination (no fee deduction)</li> </ul>"},{"location":"privacy-security-guide/#relayer-security","title":"Relayer Security","text":"<p>The relayer service (<code>api/server.py</code>) implements:</p> <ul> <li>Request serialization via <code>asyncio.Lock</code> \u2014 prevents UTXO contention</li> <li>Privacy-preserving logging \u2014 IP addresses are never logged</li> <li>Auto-retry on UTXO contention \u2014 3 attempts with 5s backoff</li> <li>Input validation passthrough \u2014 SDK validations apply server-side</li> </ul>"},{"location":"tutorial/","title":"Tutorial: Hello, Ergo!","text":"<p>This tutorial walks you through building a simple Ergo agent that can check balances, read oracle prices, and get swap quotes. Each step builds on the previous one.</p> <p>Time: ~10 minutes Prerequisites: Python 3.10+, <code>pip install ergo-agent</code></p>"},{"location":"tutorial/#step-1-connect-to-ergo","title":"Step 1: Connect to Ergo","text":"<pre><code>from ergo_agent import ErgoNode\n\nnode = ErgoNode()\nheight = node.get_height()\nprint(f\"Ergo blockchain height: {height}\")\n</code></pre> <pre><code>Ergo blockchain height: 1325847\n</code></pre> <p>That's it \u2014 you're connected. The SDK uses the public Explorer API by default, no node setup required.</p>"},{"location":"tutorial/#step-2-check-a-wallet-balance","title":"Step 2: Check a Wallet Balance","text":"<pre><code>from ergo_agent import Wallet\n\nwallet = Wallet.read_only(\"9f4QF8jQSBiHrgqrCDuS3L62MY6MaBFW5UeqNqfEi1mCfmPFxVo\")\nbalance = node.get_balance(wallet.address)\n\nprint(f\"Address: {wallet.address[:12]}...\")\nprint(f\"ERG:     {balance.erg:.4f}\")\nfor token in balance.tokens:\n    print(f\"  {token.name or token.token_id[:8]}: {token.amount_display}\")\n</code></pre> <pre><code>Address: 9f4QF8jQSBiH...\nERG:     1.2345\n  SigUSD: 50.00\n</code></pre> <p>Any address works</p> <p><code>Wallet.read_only()</code> accepts any valid Ergo address. You're just reading \u2014 no keys needed.</p>"},{"location":"tutorial/#step-3-get-the-ergusd-price","title":"Step 3: Get the ERG/USD Price","text":"<pre><code>from ergo_agent.defi import OracleReader\n\noracle = OracleReader(node)\nprice = oracle.get_erg_usd_price()\nprint(f\"ERG/USD: ${price:.4f}\")\n</code></pre> <pre><code>ERG/USD: $0.3108\n</code></pre> <p>This reads the live price from the Oracle Pool v2 \u2014 the same data feed that SigmaUSD and other Ergo DeFi protocols use.</p>"},{"location":"tutorial/#step-4-get-a-dex-quote","title":"Step 4: Get a DEX Quote","text":"<pre><code>from ergo_agent.defi import SpectrumDEX\n\ndex = SpectrumDEX(node)\nquote = dex.get_quote(token_in=\"ERG\", token_out=\"SigUSD\", amount_erg=10.0)\n\nprint(f\"Swap 10 ERG \u2192 {quote.token_out_amount / 100:.2f} SigUSD\")\nprint(f\"Fee: {quote.fee_pct:.1f}%\")\nprint(f\"Price impact: {quote.price_impact_pct:.2f}%\")\ndex.close()\n</code></pre> <pre><code>Swap 10 ERG \u2192 3.05 SigUSD\nFee: 0.3%\nPrice impact: 0.01%\n</code></pre>"},{"location":"tutorial/#step-5-wrap-it-all-in-a-toolkit","title":"Step 5: Wrap It All in a Toolkit","text":"<p>The <code>ErgoToolkit</code> bundles everything into a single interface that LLMs can call:</p> <pre><code>from ergo_agent.tools import ErgoToolkit, SafetyConfig\n\ntoolkit = ErgoToolkit(\n    node=node,\n    wallet=wallet,\n    safety=SafetyConfig(dry_run=True),  # dry_run = no real transactions\n)\n\n# Same operations, but as JSON-returning tool calls\nprint(toolkit.get_erg_price())\nprint(toolkit.get_swap_quote(token_in=\"ERG\", token_out=\"SigUSD\", amount_erg=1.0))\nprint(toolkit.get_safety_status())\n</code></pre> <p>Every method returns a JSON string that an LLM can parse and reason about.</p>"},{"location":"tutorial/#step-6-connect-to-an-llm","title":"Step 6: Connect to an LLM","text":"<p>Here's a minimal OpenAI agent:</p> <pre><code>import json\nfrom openai import OpenAI\n\nclient = OpenAI()\ntools = toolkit.to_openai_tools()\n\nmessages = [\n    {\"role\": \"system\", \"content\": \"You are an Ergo blockchain assistant.\"},\n    {\"role\": \"user\", \"content\": \"What is the current ERG price?\"},\n]\n\nresponse = client.chat.completions.create(\n    model=\"gpt-4o\",\n    tools=tools,\n    messages=messages,\n)\n\n# Handle tool calls\nfor tool_call in response.choices[0].message.tool_calls or []:\n    result = toolkit.execute_tool(tool_call.function.name, \n                                   json.loads(tool_call.function.arguments))\n    print(f\"Tool: {tool_call.function.name}\")\n    print(f\"Result: {result}\")\n</code></pre>"},{"location":"tutorial/#full-working-example","title":"Full Working Example","text":"<p>See <code>examples/04_openai_agent.py</code> for the complete, runnable version.</p>"},{"location":"tutorial/#whats-next","title":"What's Next?","text":"<ul> <li>Architecture \u2014 understand how the SDK works under the hood</li> <li>API Reference \u2014 look up specific methods</li> <li>Safety Layer \u2014 configure spending limits for production agents</li> </ul>"}]}