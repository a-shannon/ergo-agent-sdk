"""
Pool Deployer — Genesis pool creation and chaff deposit utilities.

Provides tools for:
- Deploying fresh MasterPoolBox instances with empty AVL trees
- Multi-tier pool configuration (10, 100, 1000 ERG)
- Genesis Lock threshold management
- Building chaff (dummy) deposits from the accumulator
"""

from __future__ import annotations

import hashlib
from dataclasses import dataclass
from typing import Any

from ergo_agent.crypto.pedersen import (
    NUMS_H,
    SECP256K1_P,
    encode_point,
    hash_to_curve,
)
from ergo_agent.relayer.deposit_relayer import (
    DepositRelayer,
    PoolState,
    IntentToDeposit,
    MINER_FEE,
    MIN_BOX_VALUE,
)


# ==============================================================================
# Constants
# ==============================================================================

GENESIS_THRESHOLD = 100
"""Number of deposits required before withdrawals are unlocked."""

# nanoERG per ERG
NANOERG = 1_000_000_000

# Pool tier configurations
POOL_TIERS: dict[str, dict[str, int]] = {
    "1_erg": {
        "denomination": 1 * NANOERG,
        "bounty": int(0.01 * NANOERG),    # 0.01 ERG bounty
    },
    "10_erg": {
        "denomination": 10 * NANOERG,
        "bounty": int(0.1 * NANOERG),     # 0.1 ERG bounty
    },
    "100_erg": {
        "denomination": 100 * NANOERG,
        "bounty": int(2.5 * NANOERG),     # 2.5 ERG bounty
    },
}


# Empty AVL Tree Sigma-serialized representation
# Type 0x64 (AvlTree) + 33-byte digest from AvlTreeProver(key_length=33) + flags(07)
# + keyLen(42=33 zigzag) + valueLen(00)
# The digest MUST match AvlTreeProver's initial state for proofs to verify on-chain.
EMPTY_AVL_TREE_HEX = (
    "64"
    + "befb05d26d04d4d4d1dc877f1ea2f879509a17191e5bd6e60ca98d3e3609a92500"
    + "07"               # Flags: insertions + removals + lookups
    + "2100"             # Key length: 33 (unsigned VLQ) + no value length (None)
)


# ==============================================================================
# Pool Deployer
# ==============================================================================


def build_genesis_pool_box(
    denomination: int,
    pool_ergo_tree: str,
) -> dict[str, Any]:
    """
    Create the initial MasterPoolBox output specification.

    The pool starts with:
    - R4: Empty Deposit AVL Tree
    - R5: Empty Nullifier AVL Tree
    - R6: Counter = 0
    - R7: denomination

    The pool is funded with MIN_BOX_VALUE (the deposits add ERG later).

    Args:
        denomination: Pool denomination in nanoERG.
        pool_ergo_tree: Compiled MasterPoolBox ErgoTree hex.

    Returns:
        Box output specification dict for transaction building.
    """
    return {
        "value": MIN_BOX_VALUE,
        "ergoTree": pool_ergo_tree,
        "assets": [],
        "additionalRegisters": {
            "R4": EMPTY_AVL_TREE_HEX,
            "R5": EMPTY_AVL_TREE_HEX,
            "R6": DepositRelayer._sigma_long(0),
            "R7": DepositRelayer._sigma_long(denomination),
        },
        "creationHeight": 0,
    }


def build_chaff_commitment(seed_hex: str) -> str:
    """
    Generate a permanently unspendable Pedersen Commitment for a chaff deposit.

    The commitment is generated by hashing the seed (e.g., the accumulator
    box ID) to produce a blinding factor that no one knows. This creates
    a valid commitment C = r·G + amt·H that can never be opened for
    withdrawal, permanently adding to the anonymity set.

    Algorithm:
        1. r = Blake2b256(seed_bytes) mod N   (unknowable by anyone)
        2. C = r·G + 0·H = r·G          (amount is 0 for chaff)

    Wait — chaff deposits need to look like real deposits in the tree.
    We use a commitment that IS a valid point on the curve but whose
    blinding factor is derived from a hash of the box ID, meaning no
    one can extract r to build a proveDHTuple withdrawal.

    Args:
        seed_hex: Hex string seed (typically the accumulator box ID).

    Returns:
        66-char compressed hex of the chaff commitment point.
    """
    from ergo_agent.crypto.pedersen import (
        SECP256K1_N,
        decode_point,
        G_COMPRESSED,
    )

    # Derive r = Blake2b256(seed) mod N  — Ergo's canonical hash
    seed_bytes = bytes.fromhex(seed_hex)
    digest = hashlib.blake2b(seed_bytes, digest_size=32).digest()
    r = int.from_bytes(digest, "big") % (SECP256K1_N - 1) + 1

    # C = r·G (acts as a valid commitment with unknown blinding factor)
    G = decode_point(G_COMPRESSED)
    C = r * G
    return encode_point(C)


def build_chaff_intent(
    accumulator_box_id: str,
    denomination: int,
    intent_ergo_tree: str,
) -> dict[str, Any]:
    """
    Build a chaff IntentToDeposit output from the accumulator.

    Args:
        accumulator_box_id: Box ID of the chaff accumulator being spent.
        denomination: Pool denomination in nanoERG.
        intent_ergo_tree: Compiled IntentToDeposit ErgoTree hex.

    Returns:
        Box output specification dict for the chaff intent box.
    """
    commitment_hex = build_chaff_commitment(accumulator_box_id)

    return {
        "value": denomination,
        "ergoTree": intent_ergo_tree,
        "assets": [],
        "additionalRegisters": {
            # R4: GroupElement (type 0x07 + compressed point)
            "R4": "07" + commitment_hex,
        },
        "creationHeight": 0,
    }


def is_pool_unlocked(deposit_counter: int) -> bool:
    """
    Check if a pool has passed the Genesis Lock threshold.

    Args:
        deposit_counter: Current R6 value from the MasterPoolBox.

    Returns:
        True if withdrawals are enabled (counter >= 100).
    """
    return deposit_counter >= GENESIS_THRESHOLD


def get_tier_config(tier_name: str) -> dict[str, int]:
    """
    Get the configuration for a specific pool tier.

    Args:
        tier_name: One of '10_erg', '100_erg', '1000_erg'.

    Returns:
        Dict with 'denomination' and 'bounty' keys (values in nanoERG).

    Raises:
        ValueError: If tier_name is not recognized.
    """
    if tier_name not in POOL_TIERS:
        raise ValueError(
            f"Unknown tier: {tier_name}. Available: {list(POOL_TIERS.keys())}"
        )
    return POOL_TIERS[tier_name]
